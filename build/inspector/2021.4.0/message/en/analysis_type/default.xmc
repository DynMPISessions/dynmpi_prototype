<?xml version="1.0" encoding="utf-8"?>
<!--

 Copyright Â© 2009-2021 Intel Corporation. All rights reserved.

 The information contained herein is the exclusive property of
 Intel Corporation and may not be disclosed, examined, or reproduced in
 whole or in part without explicit written authorization from the Company.

-->
<xmc version="1.1">
    <catalog name="analysis_type"  lang='en'>
        <msg name='knob.stack_depth.name'>Stack frame depth</msg>
        <msg name='knob.stack_depth.description'>Provide more or less call stack context for detected errors.&#10; &#10;A high setting is useful when analyzing highly object-oriented applications.&#10; &#10;A higher number does not significantly impact cost.&#10; &#10;Recommendation: Use only as large a value as an application requires to display complete call paths.</msg>
        <msg name='knob.remove_duplicates.name'>Remove duplicates</msg>
        <msg name='knob.remove_duplicates.description'>Do not show all occurrences of a detected problem in the Code Locations pane.&#10; &#10;Deselecting is:&#10; &#10; - Useful when you need to fully visualize all threads and problem occurrences in relation to time&#10; &#10; - Low cost in terms of time; however, the number of duplicate errors could crowd out the number of unique errors.&#10; &#10;Recommendation: Select.</msg>
        <msg name='knob.duplicate_elimination.name'>Remove duplicates</msg>
        <msg name='knob.duplicate_elimination.description'>(deprecated) Do not show all occurrences of a detected problem in the Code Locations pane.&#10; &#10;Deselecting is:&#10; &#10; - Useful when you need to fully visualize all threads and problem occurrences in relation to time&#10; &#10; - Low cost in terms of time; however, the number of duplicate errors could crowd out the number of unique errors.&#10; &#10;Recommendation: Select.</msg>
        <msg name='knob.stack_depth.1'>1</msg>
        <msg name='knob.stack_depth.4'>4</msg>
        <msg name='knob.stack_depth.8'>8</msg>
        <msg name='knob.stack_depth.12'>12</msg>
        <msg name='knob.stack_depth.16'>16</msg>
        <msg name='knob.stack_depth.20'>20</msg>
        <msg name='knob.stack_depth.24'>24</msg>
        <msg name='knob.stack_depth.28'>28</msg>
        <msg name='knob.stack_depth.32'>32</msg>
        <msg name='mc1.name'>Detect Leaks</msg>
        <msg name='mc1.description'>Narrowest scope memory error analysis. Minimizes the load on the system and the time and resources required to perform analysis; however, detects the narrowest set of errors and provides minimal details.</msg>
        <msg name='mc2.name'>Detect Memory Problems</msg>
        <msg name='mc2.description'>Medium scope memory error analysis type. Increases the load on the system and the time and resources required to perform analysis.</msg>
        <msg name='mc3.name'>Locate Memory Problems</msg>
        <msg name='mc3.description'>Widest scope memory error analysis type. Maximizes the load on the system and the time and resources required to perform analysis; however, detects the widest set of errors and provides context and maximum detail for those errors.</msg>
        <msg name='m1.name'>Detect Leaks</msg>
        <msg name='m1.description'>Detects only memory leak problems, but incurs the lowest overhead of any preset memory analysis type. Enabling On-Demand Leak Detection or Memory Growth Detection increases overhead, but allows finer analysis control.</msg>
        <msg name='m2.name'>Detect Memory Access Problems</msg>
        <msg name='m2.description'>Detects only memory access problems while minimizing overhead.</msg>
        <msg name='m3.name'>Detect Leaks and Memory Access Problems</msg>
        <msg name='m3.description'>Combines memory access and leak-related problem detection.</msg>
        <msg name='m4.name'>Detect Memory Access Problems (Deep Dive)</msg>
        <msg name='m4.description'>Detects only memory access problems, not leak-related problems. Defaults to a greater stack depth for greater problem detail.  Allows analysis of the stack, which increases overhead but detects more problems.</msg>
        <msg name='m5.name'>Detect Leaks and Memory Access Problems (Deep Dive)</msg>
        <msg name='m5.description'>Detects memory access and leak-related problems with stack analysis. Incurs the greatest overhead of all preset memory analysis types, but performs the most thorough analysis. Defaults to greater stack depth for greater problem detail, and stack analysis to maximize problem detection.</msg>
        <msg name='knob.stack_depth_mc.description'>Provide more or less call stack context for detected errors.&#10; &#10;A high setting is useful when analyzing highly object-oriented applications.&#10; &#10;A higher number does not significantly impact cost.&#10; &#10;Recommendation: Use only as large a value as an application requires to display complete call paths.</msg>
        <msg name='knob.detect_resource_leaks.name'>Detect resource leaks</msg>
        <msg name='knob.detect_resource_leaks.description'>Detect problems where:&#10; &#10; - A kernel object handle is created but never closed.&#10; &#10; - A GDI object is created but never deleted.&#10; &#10;Selecting is useful when analyzing Windows* GUI applications.&#10; &#10;Low cost.&#10; &#10;Recommendation: Select the first time you analyze an application and periodically thereafter.</msg>
        <msg name='knob.resources.name'>Detect resource leaks</msg>
        <msg name='knob.resources.description'>(deprecated) Detect problems where:&#10; &#10; - A kernel object handle is created but never closed.&#10; &#10; - A GDI object is created but never deleted.&#10; &#10;Selecting is useful when analyzing Windows* GUI applications.&#10; &#10;Low cost.&#10; &#10;Recommendation: Select the first time you analyze an application and periodically thereafter.</msg>
        <msg name='knob.detect_leaks_on_demand.name'>Enable on-demand memory leak detection</msg>
        <msg name='knob.detect_leaks_on_demand_exp.name'>Enable on-demand leak detection</msg>
        <msg name='knob.detect_leaks_on_demand.description'>Enable the ability to detect if a block of memory is allocated, but not deallocated and not reachable (there is no pointer available to deallocate the bock), within a specific time segment during application execution. &#10; &#10;Selecting is useful for checking for memory leaks in an application that never exits, or in only the portion of an application for which you are responsible. (Use in conjunction with the Reset Leak/Growth Detection button and Show Leaks/Growth Now button during analysis.) &#10; &#10;Cost is proportional to the number of allocations.</msg>
        <msg name='knob.detect_invalid_accesses.name'>Detect invalid memory accesses</msg>
        <msg name='knob.detect_invalid_accesses.description'>Detect problems where an instruction reads or writes an uninitialized or invalid memory location. &#10; &#10;Selecting is useful when an application: &#10; &#10; - Exhibits unexpected behavior. &#10; &#10; - Shows evidence of uninitialized values in computations. &#10; &#10;High cost. &#10; &#10;Recommendation: Select.</msg>
        <msg name='knob.defer_memory_deallocation.name'>Defer memory deallocation</msg>
        <msg name='knob.defer_memory_deallocation.description'>Have the Intel Inspector prevent freed memory blocks from immediately returning to the pool of available memory. &#10; &#10;Selecting is useful for discovering if an application tries to use memory after freeing it. &#10; &#10;High cost if an application is performing many allocations/deallocations. &#10; &#10;Recommendation: Select to improve analysis quality if the cost is not too high.</msg>
        <msg name='knob.analyze_stack.name'>Analyze stack accesses</msg>
        <msg name='knob.analyze_stack.description'>Analyze invalid and uninitialized accesses to thread stacks.&#10; &#10;Selecting is useful when:&#10; &#10;- You want as thorough an analysis as possible.&#10; &#10;- An application calls alloca().&#10; &#10;High cost.&#10; &#10;Recommendation:&#10; &#10; - Select the first time you analyze an application and periodically thereafter.&#10; &#10; - Select to analyze automatic variables.</msg>
        <msg name='knob.still_allocated_memory.name'>Report still-allocated memory at application exit</msg>
        <msg name='knob.still_allocated_memory_exp.name'>Detect still-allocated memory at application exit</msg>
        <msg name='knob.still_allocated_memory.description'>Detect problems where a still-reachable block of memory is allocated but not released when the application stops executing.&#10; &#10;Cost is proportional to the number of memory blocks still allocated when the application stops executing.&#10; &#10;Recommendation: Select to investigate memory growth.</msg>
        <msg name='knob.detect_leaks_on_exit.name'>Detect memory leaks upon application exit</msg>
        <msg name='knob.detect_leaks_on_exit_exp.name'>Detect leaks at application exit</msg>
        <msg name='knob.detect_leaks_on_exit.description'>Detect problems where a block of memory is allocated but never released when an application stops executing. &#10; &#10;Selecting is useful when an application:&#10; &#10; - Runs out of memory.&#10; &#10; - Appears to be using more memory than expected. &#10; &#10;Extremely low cost - especially if used only with the Remove duplicates checkbox selected. &#10; &#10;Recommendation: Select.</msg>
        <msg name='knob.enable_memory_growth_detection.name'>Enable interactive memory growth detection</msg>
        <msg name='knob.enable_memory_growth_detection_exp.name'>Enable memory growth detection</msg>
        <msg name='knob.enable_memory_growth_detection.description'>Enable the ability to detect if a block of memory is allocated, but not deallocated, within a specific time segment during application execution.&#10; &#10;Selecting is useful for modeling memory usage patterns and ensuring a transactional application deallocates all memory allocations after a transaction completes. (Use in conjunction with the Reset Leak/Growth Detection button and Show Leaks/Growth Now button during analysis.)&#10; &#10;Low cost.</msg>
        <msg name='thread_checker.name'>Threading Errors</msg>
        <msg name='thread_checker.description'>Choose a preset analysis type designed to help you control analysis cost (duration). If the combination of analysis type settings in none of the preset analysis types meets your needs, try creating a custom analysis type.</msg>
        <msg name='knob.stack_depth_tc_exp.description'>Provide more or less call stack context for detected errors.&#10; &#10;A high setting is useful when analyzing highly object-oriented applications.&#10; &#10;A higher number does not significantly impact cost with one exception: Choosing a higher number plus selecting the Save stack on first access checkbox increases cost.&#10; &#10;Recommendation: Use only as large a value as an application requires to display complete call paths.</msg>
        <msg name='knob.terminate_on_deadlock.name'>Terminate on deadlock</msg>
        <msg name='knob.terminate_on_deadlock.description'>Stop analysis and application execution if the Intel Inspector detects a deadlock.&#10; &#10;Selecting is useful when running your application as part of a kernel or unit testing suite.&#10; &#10;Low cost.&#10; &#10;Recommendation: Deselect. Instead, use the corresponding knob in the command line interface to perform kernel or unit testing in a nightly scenario. If the Intel Inspector identifies a deadlock, decide if it is appropriate to continue analysis.</msg>
        <msg name='knob.check_potential_deadlock.name'>Detect lock hierarchy violations</msg>
        <msg name='knob.check_potential_deadlock.description'>Detect problems where the acquisition hierarchy order of multiple synchronization objects in one thread differs from the acquisition hierarchy order in another thread, and could cause a deadlock under certain conditions.&#10; &#10;Selecting is useful when an application has complicated synchronization and it is hard to verify correctness.&#10; &#10;Low cost unless an application has a significant number of locks.</msg>
        <msg name='knob.save_stack_on_lock_creation.name'>Save stack on lock creation</msg>
        <msg name='knob.save_stack_on_lock_creation.description'>Show creation information on synchronization objects involved in deadlocks, lock hierarchy violations, and data races.&#10; &#10;Selecting is useful when acquisition stacks are not sufficient to understand the problem.&#10; &#10;Low cost.</msg>
        <msg name='knob.save_stack_on_first_access.name'>Save stack on first access</msg>
        <msg name='knob.save_stack_on_first_access.description'>Show as much information as possible on all threads involved in a data race.&#10; &#10;Selecting is useful when investigating complex data race problems.&#10; &#10;High cost.&#10; &#10;Recommendation: Deselect on initial analysis runs. Select only when you need the maximum information and context about all threads involved in a data race to solve the problem.</msg>
        <msg name='knob.save_stack_on_allocation.name'>Save stack on memory allocation</msg>
        <msg name='knob.save_stack_on_allocation.description'>Identify the allocation site of dynamically allocated memory objects involved in data races.&#10; &#10;Medium cost.&#10; &#10;Recommendation: Select when you need to identify the object hierarchy of low-level objects involved in data races. For example: If object R is involved in a data race and is instantiated within objects O1, O2, and O3, the allocation call stack can help you identify which encapsulating object is not properly protecting access to object R.</msg>
        <msg name='knob.use_maximum_resources.name'>Use maximum resources</msg>
        <msg name='knob.use_maximum_resources.description'>Potentially detect more data race and cross-thread stack access errors; however, do not optimize memory consumption and performance.&#10; &#10;High cost.&#10; &#10;Recommendation: Deselect to find most of your threading problems. After you find and fix the problems, select for more complete coverage.</msg>
        <msg name='knob.detect_races_on_stack_access.name'>Detect data races on stack accesses</msg>
        <msg name='knob.detect_races_on_stack_access_exp.name'>Detect data races on stack</msg>
        <msg name='knob.detect_races_on_stack_access.description'>Detect data races for variables allocated on the stack. &#10; &#10;High cost.</msg>
        <msg name='knob.detect_races_on_stack_access_exp.description'>Detect data races for variables allocated on the stack.&#10; &#10;Selecting is useful when threads in an application share variables from the stack and you suspect data races on the variables.&#10; &#10;High cost.&#10; &#10;Recommendation: Deselect. If you select, consider also selecting the Defer memory tracing checkbox and the Sample memory accesses checkbox to reduce cost.</msg>
        <msg name='knob.resolution.name'>Race analysis byte granularity</msg>
        <msg name='knob.resolution.description'>Set the size of the smallest memory block the Intel Inspector considers a single block of memory when determining if non-synchronized accesses to a memory block constitute a data race.&#10; &#10;Selecting is useful to control memory consumption during analysis for some applications.&#10; &#10;High cost when set to 1 byte.&#10; &#10;Recommendation: Set to 4 unless you continually see data races based on safe access to smaller memory blocks. If so, reset to 1.</msg>
        <msg name='knob.resolution.standard.name'>4 bytes</msg>
        <msg name='knob.resolution.fine.name'>2 bytes</msg>
        <msg name='knob.resolution.superfine.name'>1 byte</msg>
        <msg name='knob.filter_guaranteed_atomics.name'>Filter guaranteed atomics</msg>
        <msg name='knob.filter_guaranteed_atomics.description'>Do not report races on guaranteed atomic operations on Intel(R) P6 processor family or newer.&#10;&#10;For details, please refer to Chapter 8.1.1 &quot;Guaranteed Atomic Operations&quot; of the Intel(R) 64 and IA-32 Architectures Software Developer's Manual, Volume 3A.&#10;&#10;Use with caution, other architectures might have another policy on atomic operations.</msg>
        <msg name='knob.defer_memory_check.name'>Defer memory tracing</msg>
        <msg name='knob.defer_memory_check.description'>Do not look for data races in a given block of memory until the block is accessed by more than one thread.&#10; &#10;Selecting is useful for limiting memory consumption during analysis but less useful for analyzing simple sample code.&#10; &#10;Reduces the cost of data race detection.&#10; &#10;Recommendation: Select. Only disadvantage: The Intel Inspector may miss atypical data races because it does not capture information for first thread access until it knows the block is touched by more than one thread.</msg>
        <msg name='knob.tcscope.name'>Scope</msg>
        <msg name='knob.tcscope.description'>Normal/normal=Set memory access byte granularity to 4 bytes, do not detect data races on stack accesses, and defer memory check. High cost.&#10;&#10;Extremely thorough/extreme=Set memory access byte granularity to 1 byte, detect data races on stack accesses, and do not defer memory check. Extremely high cost.</msg>
        <msg name='knob.tcscope.l1'>Normal</msg>
        <msg name='knob.tcscope.l2'>Extremely thorough</msg>
        <msg name='tc1.name'>Detect Deadlocks</msg>
        <msg name='tc1.description'>Narrowest scope threading error analysis. Minimizes the load on the system and the time and resources required to perform analysis; however, detects the narrowest set of errors and provides minimal details.</msg>
        <msg name='tc2.name'>Detect Deadlocks and Data Races</msg>
        <msg name='tc2.description'>Medium scope threading error analysis type. Increases the load on the system and the time and resources required to perform analysis.</msg>
        <msg name='tc3.name'>Locate Deadlocks and Data Races </msg>
        <msg name='tc3.description'>Widest scope threading error analysis type. Maximizes the load on the system and the time and resources required to perform analysis; however, detects the widest set of errors and provides context and maximum detail for those errors.</msg>
        <msg name='t1.name'>Detect Deadlocks</msg>
        <msg name='t1.description'>Detects only deadlock problems, but incurs the lowest overhead of any preset threading analysis type.</msg>
        <msg name='t2.name'>Detect Data Races</msg>
        <msg name='t2.description'>Detects only data race problems while minimizing overhead.</msg>
        <msg name='t3.name'>Detect Deadlocks and Data Races</msg>
        <msg name='t3.description'>Combines deadlock and data race problem detection.</msg>
        <msg name='t4.name'>Detect Data Races (Deep Dive)</msg>
        <msg name='t4.description'>Detects only data race problems. Defaults to a greater stack depth for greater problem detail. Allows analysis of the stack, which increases overhead but potentially detects more problems.</msg>
        <msg name='t5.name'>Detect Deadlocks and Data Races (Deep Dive)</msg>
        <msg name='t5.description'>Detects deadlock and data race problems with stack analysis. Incurs the greatest overhead of all preset threading analysis types, but performs the most thorough analysis. Defaults to greater stack depth for greater problem detail, and stack analysis to maximize problem detection.</msg>
        <msg name='source_checker.name'>Static Analysis</msg>
        <msg name='source_checker.description'>Result created by an Intel(R) compiler in various Intel(R) suite products.</msg>
        <msg name='diff.name'>Compared Result</msg>
        <msg name='diff.description'>Temporary result comparing two results to identify issues that exist in one but not the other, or that still exist in both.</msg>
        <msg name='custom_analysis_types.name'>Custom Analysis Types</msg>
        <msg name='custom_analysis_types.description'>Use custom analysis types when the combination of analysis type settings in the preset analysis types does not meet your needs.</msg>
        <msg name='memory_errors.name'>Memory Error Analysis</msg>
        <msg name='memory_errors.description'>Use memory error analysis types to search for these kinds of errors: Resource leak, incorrect memcpy call, invalid deallocation, invalid partial memory access, memory growth, memory leak, memory not deallocated, mismatched allocation/deallocation, missing allocation, uninitialized memory access, and uninitialized partial memory access.</msg>
        <msg name='threading_errors.name'>Threading Error Analysis</msg>
        <msg name='threading_errors.description'>Use threading error analysis types to search for these kinds of errors: Data race, deadlock, lock hierarchy violation, and cross-thread stack access.</msg>
        <msg name='pmem.name'>Examine Persistence Inspector Result</msg>
        <msg name='pmem.description'>Locate errors in persistent memory applications, such as cache flush misses, redundant cache flushes and memory fences, out-of-order persistent memory stores, and incorrect undo logging for the Persistent Memory Development Kit (PMDK), previously known as the Non-Volatile Memory Library (NVML).</msg>
    </catalog>
</xmc>
