<?xml version="1.0" encoding="utf-8"?>
<!--

 Copyright Â© 2009-2021 Intel Corporation. All rights reserved.

 The information contained herein is the exclusive property of
 Intel Corporation and may not be disclosed, examined, or reproduced in
 whole or in part without explicit written authorization from the Company.

-->
<xmc version="1.1">
    <catalog name="analysis_type"  lang='en'>
        <msg name='runxx.cknob_stack_depth.name'>Stack frame depth</msg>
        <msg name='runxx.cknob_stack_depth.description'>Provide more or less call stack context for detected errors.&#10; &#10;A high setting is useful when analyzing highly object-oriented applications.&#10; &#10;A higher number does not significantly impact cost.&#10; &#10;Recommendation: Use only as large a value as an application requires to display complete call paths.</msg>
        <msg name='runmc.cknob_stack_depth.description'>Provide more or less call stack context for detected errors.&#10; &#10;A high setting is useful when analyzing highly object-oriented applications.&#10; &#10;A higher number does not significantly impact cost.&#10; &#10;Recommendation: Use only as large a value as an application requires to display complete call paths.</msg>
        <msg name='runtc.cknob_stack_depth_exp.description'>Provide more or less call stack context for detected errors.&#10; &#10;A high setting is useful when analyzing highly object-oriented applications.&#10; &#10;A higher number does not significantly impact cost with one exception: Choosing a higher number plus selecting the Save stack on first access checkbox increases cost.&#10; &#10;Recommendation: Use only as large a value as an application requires to display complete call paths.</msg>
        <msg name='runxx.remove_duplicates.name'>Remove duplicates</msg>
        <msg name='runxx.remove_duplicates.description'>Do not show all occurrences of a detected problem in the Code Locations pane.&#10; &#10;Deselecting is:&#10; &#10; - Useful when you need to fully visualize all threads and problem occurrences in relation to time&#10; &#10; - Low cost in terms of time; however, the number of duplicate errors could crowd out the number of unique errors.&#10; &#10;Recommendation: Select.</msg>
        <msg name='runxx.duplicate_elimination.name'>Remove duplicates</msg>
        <msg name='runxx.duplicate_elimination.description'>(deprecated) Do not show all occurrences of a detected problem in the Code Locations pane.&#10; &#10;Deselecting is:&#10; &#10; - Useful when you need to fully visualize all threads and problem occurrences in relation to time&#10; &#10; - Low cost in terms of time; however, the number of duplicate errors could crowd out the number of unique errors.&#10; &#10;Recommendation: Select.</msg>
        <msg name='runtc.cknob_check_deadlock.name'>Detect deadlocks</msg>
        <msg name='runtc.cknob_check_deadlock.description'>Useful when an application has complicated synchronization and it is hard to verify correctness, or when you suspect deadlock problems that are not yet evident. &#10; &#10;Low cost unless an application has a significant number of locks.</msg>
        <msg name='runtc.cknob_check_deadlock_exp.description'>Detect problems where two or more threads are waiting for the other to release resources, but none of the threads releases the resources. Thus no thread can proceed.&#10; &#10;Selecting is useful when you want to troubleshoot the location of a deadlock.&#10; &#10;Low cost.</msg>
        <msg name='runtc.cknob_check_datarace.name'>Detect data races</msg>
        <msg name='runtc.cknob_check_datarace.description'>Detect problems where multiple threads access the same memory location without proper synchronization and at least one access is a write. &#10; &#10;High cost.</msg>
        <msg name='runtc.cknob_check_datarace_exp.description'>Detect problems where multiple threads access the same memory location without proper synchronization and at least one access is a write.&#10; &#10;Selecting is useful when you suspect data races that are not yet evident.&#10; &#10;High cost.&#10; &#10;Recommendation: Select. Consider also selecting the Defer memory tracing checkbox and the Sample memory accesses checkbox to reduce cost.</msg>
        <msg name='runtc.cknob_terminate_on_deadlock.name'>Terminate on deadlock</msg>
        <msg name='runtc.cknob_terminate_on_deadlock.description'>Stop analysis and application execution if the Intel Inspector detects a deadlock.&#10; &#10;Selecting is useful when running your application as part of a kernel or unit testing suite.&#10; &#10;Low cost.&#10; &#10;Recommendation: Deselect. Instead, use the corresponding knob in the command line interface to perform kernel or unit testing in a nightly scenario. If the Intel Inspector identifies a deadlock, decide if it is appropriate to continue analysis.</msg>
        <msg name='runtc.cknob_check_potential_deadlock.name'>Detect lock hierarchy violations</msg>
        <msg name='runtc.cknob_check_potential_deadlock.description'>Detect problems where the acquisition hierarchy order of multiple synchronization objects in one thread differs from the acquisition hierarchy order in another thread, and could cause a deadlock under certain conditions.&#10; &#10;Selecting is useful when an application has complicated synchronization and it is hard to verify correctness.&#10; &#10;Low cost unless an application has a significant number of locks.</msg>
        <msg name='runtc.cknob_save_stack_on_lock_creation.name'>Save stack on lock creation</msg>
        <msg name='runtc.cknob_save_stack_on_lock_creation.description'>Show creation information on synchronization objects involved in deadlocks, lock hierarchy violations, and data races.&#10; &#10;Selecting is useful when acquisition stacks are not sufficient to understand the problem.&#10; &#10;Low cost.</msg>
        <msg name='runtc.cknob_check_cross_thread_stack_access.name'>Cross-thread stack access detection</msg>
        <msg name='runtc.cknob_check_cross_thread_stack_access.description'>Set the alert mechanism for when a thread accesses stack memory of another thread. The alert mechanism helps you decide if this is an issue that requires handling. All options are low cost if Detect data races=Select/Yes/true. &#10; &#10;Use Hide problems/Hide warnings (none) if using an OpenMP*, Intel(R) Threading Building Blocks, or Intel(R) Cilk(TM) Plus programming model; or if cross-thread stack accesses are anticipated. Recommendation: Also select Detect races on stack accesses. &#10; &#10;Use Hide problems/Show warnings (warnings) if cross-thread stack accesses are not anticipated. Recommendation: Also deselect Detect races on stack accesses. &#10; &#10;Use Show problems/Hide warnings (problems) if cross-thread stack accesses are not anticipated but a previous analysis indicated they exist and you are not using an OpenMP, Intel Threading Building Blocks, or Intel Cilk Plus programming model. Recommendation: Also deselect Detect races on stack accesses.</msg>
        <msg name='runtc.cknob_check_cross_thread_stack_access_exp.description'>Set the alert mechanism for when a thread accesses stack memory of another thread.&#10; &#10;The alert mechanism helps you decide if this is an issue that requires handling.&#10; &#10;All options are low cost if the Detect data races checkbox is selected.&#10; &#10;Recommendation:&#10; &#10; - Use the Hide problems/Hide warnings option if using an OpenMP*, Intel(R) Threading Building Blocks, or Intel(R) Cilk(TM) Plus programming model; or if cross-thread stack accesses are anticipated. Also select the Detect races on stack checkbox.&#10; &#10; - Use the Hide problems/Show warnings option if cross-thread stack accesses are not anticipated. Also deselect the Detect data races on stack checkbox.&#10; &#10; - Use the Show problems/Hide warnings option if cross-thread stack accesses are not anticipated but a previous analysis indicated they exist and you are not using an OpenMP*, Intel Threading Building Blocks, or Intel Cilk Plus programming model. Also deselect the Detect data races on stack checkbox.</msg>
        <msg name='runtc.cknob_check_cross_thread_stack_access.opt1.name'>Hide problems/Hide warnings</msg>
        <msg name='runtc.cknob_check_cross_thread_stack_access.opt2.name'>Hide problems/Show warnings</msg>
        <msg name='runtc.cknob_check_cross_thread_stack_access.opt3.name'>Show problems/Hide warnings</msg>
        <msg name='runtc.cknob_detect_races_on_stack_access.name'>Detect data races on stack accesses</msg>
        <msg name='runtc.cknob_detect_races_on_stack_access_exp.name'>Detect data races on stack</msg>
        <msg name='runtc.cknob_detect_races_on_stack_access_exp.description'>Detect data races for variables allocated on the stack.&#10; &#10;Selecting is useful when threads in an application share variables from the stack and you suspect data races on the variables.&#10; &#10;High cost.&#10; &#10;Recommendation: Deselect. If you select, consider also selecting the Defer memory tracing checkbox and the Sample memory accesses checkbox to reduce cost.</msg>
        <msg name='runtc.cknob_detect_races_on_stack_access.description'>Detect data races for variables allocated on the stack. &#10; &#10;High cost.</msg>
        <msg name='runtc.cknob_resolution.name'>Memory access byte granularity</msg>
        <msg name='runtc.cknob_resolution_exp.name'>Race analysis byte granularity</msg>
        <msg name='runtc.cknob_resolution.description'>Set the size of the smallest memory block the Intel Inspector considers a single block of memory when determining if non-synchronized accesses to a memory block constitute a data race.&#10; &#10;Selecting is useful to control memory consumption during analysis for some applications.&#10; &#10;High cost when set to 1 byte.&#10; &#10;Recommendation: Set to 4 unless you continually see data races based on safe access to smaller memory blocks. If so, reset to 1.</msg>
        <msg name='runtc.cknob_resolution.standard.name'>4 bytes</msg>
        <msg name='runtc.cknob_resolution.fine.name'>2 bytes</msg>
        <msg name='runtc.cknob_resolution.superfine.name'>1 byte</msg>
        <msg name='runtc.cknob_filter_guaranteed_atomics.name'>Filter guaranteed atomics</msg>
        <msg name='runtc.cknob_filter_guaranteed_atomics.description'>Do not report races on guaranteed atomic operations on Intel(R) P6 processor family or newer.&#10;&#10;For details, please refer to Chapter 8.1.1 &quot;Guaranteed Atomic Operations&quot; of the Intel(R) 64 and IA-32 Architectures Software Developer's Manual, Volume 3A.&#10;&#10;Use with caution, other architectures might have another policy on atomic operations.</msg>
        <msg name='runtc.cknob_defer_memory_check.name'>Defer memory tracing</msg>
        <msg name='runtc.cknob_defer_memory_check_exp.name'>Defer memory check</msg>-->
        <msg name='runtc.cknob_defer_memory_check.description'>Do not look for data races in a given block of memory until the block is accessed by more than one thread.&#10; &#10;Selecting is useful for limiting memory consumption during analysis but less useful for analyzing simple sample code.&#10; &#10;Reduces the cost of data race detection.&#10; &#10;Recommendation: Select. Only disadvantage: The Intel Inspector may miss atypical data races because it does not capture information for first thread access until it knows the block is touched by more than one thread.</msg>
        <msg name='runtc.cknob_save_stack_on_first_access.name'>Save stack on first access</msg>
        <msg name='runtc.cknob_save_stack_on_first_access.description'>Show as much information as possible on all threads involved in a data race.&#10; &#10;Selecting is useful when investigating complex data race problems.&#10; &#10;High cost.&#10; &#10;Recommendation: Deselect on initial analysis runs. Select only when you need the maximum information and context about all threads involved in a data race to solve the problem.</msg>
        <msg name='runtc.cknob_save_stack_on_allocation.name'>Save stack on allocation</msg>
        <msg name='runtc.cknob_save_stack_on_allocation_exp.name'>Save stack on memory allocation</msg>
        <msg name='runtc.cknob_save_stack_on_allocation.description'>Identify the allocation site of dynamically allocated memory objects involved in data races.&#10; &#10;Medium cost.&#10; &#10;Recommendation: Select when you need to identify the object hierarchy of low-level objects involved in data races. For example: If object R is involved in a data race and is instantiated within objects O1, O2, and O3, the allocation call stack can help you identify which encapsulating object is not properly protecting access to object R.</msg>
        <msg name='runtc.cknob_use_maximum_resources.name'>Use maximum resources</msg>
        <msg name='runtc.cknob_use_maximum_resources.description'>Potentially detect more data race and cross-thread stack access errors; however, do not optimize memory consumption and performance.&#10; &#10;High cost.&#10; &#10;Recommendation: Deselect to find most of your threading problems. After you find and fix the problems, select for more complete coverage.</msg>
        <msg name='runmc.cknob_detect_resource_leaks.name'>Detect resource leaks</msg>
        <msg name='runmc.cknob_detect_resource_leaks.description'>Detect problems where:&#10; &#10; - A kernel object handle is created but never closed.&#10; &#10; - A GDI object is created but never deleted.&#10; &#10;Selecting is useful when analyzing Windows* GUI applications.&#10; &#10;Low cost.&#10; &#10;Recommendation: Select the first time you analyze an application and periodically thereafter.</msg>
        <msg name='runmc.cknob_still_allocated_memory.name'>Report still-allocated memory at application exit</msg>
        <msg name='runmc.cknob_still_allocated_memory_exp.name'>Detect still-allocated memory at application exit</msg>
        <msg name='runmc.cknob_still_allocated_memory.description'>Detect problems where a still-reachable block of memory is allocated but not released when the application stops executing.&#10; &#10;Cost is proportional to the number of memory blocks still allocated when the application stops executing.&#10; &#10;Recommendation: Select to investigate memory growth.</msg>
        <msg name='runmc.cknob_detect_leaks_on_exit.name'>Detect memory leaks upon application exit</msg>
        <msg name='runmc.cknob_detect_leaks_on_exit_exp.name'>Detect leaks at application exit</msg>
        <msg name='runmc.cknob_detect_leaks_on_exit.description'>Detect problems where a block of memory is allocated but never released when an application stops executing. &#10; &#10;Selecting is useful when an application:&#10; &#10; - Runs out of memory.&#10; &#10; - Appears to be using more memory than expected. &#10; &#10;Extremely low cost - especially if used only with the Remove duplicates checkbox selected. &#10; &#10;Recommendation: Select.</msg>
        <msg name='runmc.cknob_detect_memory_leaks.name'>Detect memory leaks</msg>
        <msg name='runmc.cknob_detect_memory_leaks.description'>(deprecated) Detect problems where a block of memory is allocated but never released. &#10; &#10;Extremely low cost, especially if used only with Remove Duplicates selected.</msg>
        <msg name='runmc.cknob_detect_leaks_on_demand.name'>Enable on-demand memory leak detection</msg>
        <msg name='runmc.cknob_detect_leaks_on_demand_exp.name'>Enable on-demand leak detection</msg>
        <msg name='runmc.cknob_detect_leaks_on_demand.description'>Enable the ability to detect if a block of memory is allocated, but not deallocated and not reachable (there is no pointer available to deallocate the bock), within a specific time segment during application execution. &#10; &#10;Selecting is useful for checking for memory leaks in an application that never exits, or in only the portion of an application for which you are responsible. (Use in conjunction with the Reset Leak/Growth Detection button and Show Leaks/Growth Now button during analysis.) &#10; &#10;Cost is proportional to the number of allocations.</msg>
        <msg name='runmc.cknob_detect_invalid_accesses.name'>Detect invalid memory accesses</msg>
        <msg name='runmc.cknob_detect_invalid_accesses.description'>Select/Yes/true=Detect problems where a read or write instruction references memory that is logically or physically invalid.&#10; &#10;Selecting is useful to ensure an application accesses only valid memory.&#10; &#10;Medium cost.&#10; &#10;Recommendation: Select. </msg>
        <msg name='runmc.cknob_analyze_stack.name'>Analyze stack accesses</msg>
        <msg name='runmc.cknob_analyze_stack.description'>Analyze invalid and uninitialized accesses to thread stacks.&#10; &#10;Selecting is useful when:&#10; &#10;- You want as thorough an analysis as possible.&#10; &#10;- An application calls alloca().&#10; &#10;High cost.&#10; &#10;Recommendation:&#10; &#10; - Select the first time you analyze an application and periodically thereafter.&#10; &#10; - Select to analyze automatic variables.</msg>
        <msg name='runmc.cknob_dangling_pointer_check.name'>Enable enhanced dangling pointer check</msg>
        <msg name='runmc.cknob_dangling_pointer_check.description'>Detect if an application is trying to access memory after it was logically freed. &#10; &#10;May be higher cost if an application is performing many allocations/deallocations, and the Byte limit before reallocation list value is smaller than the amount of memory the application allocates.</msg>
        <msg name='runmc.cknob_defer_memory_deallocation.name'>Defer memory deallocation</msg>
        <msg name='runmc.cknob_defer_memory_deallocation.description'>Have the Intel Inspector prevent freed memory blocks from immediately returning to the pool of available memory. &#10; &#10;Selecting is useful for discovering if an application tries to use memory after freeing it. &#10; &#10;High cost if an application is performing many allocations/deallocations. &#10; &#10;Recommendation: Select to improve analysis quality if the cost is not too high.</msg>
        <msg name='runmc.cknob_byte_limit.name'>Byte limit before reallocation</msg>
        <msg name='runmc.cknob_byte_limit.description'>Have the Intel Inspector prevent freed memory blocks from immediately returning to the pool of available memory.&#10; &#10;Selecting is useful for discovering if an application tries to use memory after freeing it.&#10; &#10;High cost if an application is performing many allocations/deallocations.&#10; &#10;Recommendation: Select to improve analysis quality if the cost is not too high.</msg>
        <msg name='runmc.cknob_byte_limit.10K'>10 Kb</msg>
        <msg name='runmc.cknob_byte_limit.100K'>100 Kb</msg>
        <msg name='runmc.cknob_byte_limit.1M'>1 Mb</msg>
        <msg name='runmc.cknob_byte_limit.10M'>10 Mb</msg>
        <msg name='runmc.cknob_byte_limit.100M'>100 Mb</msg>
        <msg name='runmc.cknob_guard_zones.name'>Enable guard zones</msg>
        <msg name='runmc.cknob_guard_zones.description'>Show offset information if the Intel Inspector detects memory use beyond the end of an allocated block. &#10; &#10;Useful when an application exhibits unexpected behavior, or when you need more context about heap allocations to interpret Invalid memory access problems. &#10; &#10;Low cost.</msg>
        <msg name='runmc.cknob_guard_zone_size.name'>Guard zone size</msg>
        <msg name='runmc.cknob_guard_zone_size.description'>Set to a number greater than 0 to show offset information if the Intel Inspector detects memory use beyond the end of an allocated block; set to 0 to disable.&#10; &#10;A number greater than 0 identifies the number of bytes beyond the allocated block of memory the Intel Inspector reserves to identify Invalid memory access problems related to the allocation. Setting to a number greater than 0 is useful when:&#10; &#10; - An application exhibits unexpected behavior.&#10; &#10; - You need more context about heap allocations to interpret Invalid memory access problems..&#10; &#10;Cost is proportional to number of allocations..&#10; &#10;Recommendation: Set to a number greater than 0 unless:&#10; &#10; - Intel Inspector runs out of memory.&#10; &#10; - An application becomes destabilized.</msg>
        <msg name='runmc.cknob_guard_zone_size.8'>8 bytes</msg>
        <msg name='runmc.cknob_guard_zone_size.16'>16 bytes</msg>
        <msg name='runmc.cknob_guard_zone_size.32'>32 bytes</msg>
        <msg name='runmc.cknob_guard_zone_size.64'>64 bytes</msg>
        <msg name='runmc.cknob_guard_zone_size.128'>128 bytes</msg>
        <msg name='runmc.cknob_leak_maximum.name'>Maximum memory leaks</msg>
        <msg name='runmc.cknob_leak_maximum_exp.name'>Maximum memory leaks shown in result</msg>
        <msg name='runmc.cknob_leak_maximum.description'>Set the maximum number of leaks the Intel Inspector shows in a result after analysis is complete.&#10; &#10;A zero setting shows all detected memory leaks.&#10; &#10;Cost is proportional to the number of leaks.&#10; &#10;Recommendation: Use the default value unless you want an exhaustive list of all leaks.</msg>
        <msg name='runmc.cknob_enable_memory_growth_detection.name'>Enable interactive memory growth detection</msg>
        <msg name='runmc.cknob_enable_memory_growth_detection_exp.name'>Enable memory growth detection</msg>
        <msg name='runmc.cknob_enable_memory_growth_detection.description'>Enable the ability to detect if a block of memory is allocated, but not deallocated, within a specific time segment during application execution.&#10; &#10;Selecting is useful for modeling memory usage patterns and ensuring a transactional application deallocates all memory allocations after a transaction completes. (Use in conjunction with the Reset Leak/Growth Detection button and Show Leaks/Growth Now button during analysis.)&#10; &#10;Low cost.</msg>
        <msg name='collector.mc.name'>Memory Errors</msg>
        <msg name='collector.tc.name'>Threading Errors</msg>
    </catalog>
</xmc>
